pats <- read.table("../data/pyAnalysisOutput/techAreaTopicDist4R.data",sep=",")
pats
pats[1:4]
pats[13:15]
scatterplotMatrix(pats[2:6])
library("car")
scatterplotMatrix(pats[2:6])
jpeg(file="scatterPats.jpg")
scatterplotMatrix(pats[2:6])
dev.off()
jpeg(file="scatterPats.jpg")
scatterplotMatrix(pats[2:15])
dev.off()
jpeg(file="scatterPats2-6.jpg")
scatterplotMatrix(pats[2:6])
dev.off()
jpeg(file="scatterPats7-11.jpg")
scatterplotMatrix(pats[7:11])
dev.off()
jpeg(file="scatterPats12-16.jpg")
scatterplotMatrix(pats[12:16])
dev.off()
makeProfilePlot <- function(mylist,names)
  {
     require(RColorBrewer)
     # find out how many variables we want to include
     numvariables <- length(mylist)
     # choose 'numvariables' random colours
     colours <- brewer.pal(numvariables,"Set1")
     # find out the minimum and maximum values of the variables:
     mymin <- 1e+20
     mymax <- 1e-20
     for (i in 1:numvariables)
     {
        vectori <- mylist[[i]]
        mini <- min(vectori)
        maxi <- max(vectori)
        if (mini < mymin) { mymin <- mini }
        if (maxi > mymax) { mymax <- maxi }
     }
     # plot the variables
     for (i in 1:numvariables)
     {
        vectori <- mylist[[i]]
        namei <- names[i]
        colouri <- colours[i]
        if (i == 1) { plot(vectori,col=colouri,type="l",ylim=c(mymin,mymax)) }
        else         { points(vectori, col=colouri,type="l")                                     }
        lastxval <- length(vectori)
        lastyval <- vectori[length(vectori)]
        text((lastxval-10),(lastyval),namei,col="black",cex=0.6)
     }
  }
library(RColorBrewer)
install.packages()
library(RColorbrewer)
exit
q()
pats
printMeanAndSdByGroup(pats.lda.values$x,pats[1])
printMeanAndSdByGroup <- function(variables,groupvariable)
  {
     # find the names of the variables
     variablenames <- c(names(groupvariable),names(as.data.frame(variables)))
     # within each group, find the mean of each variable
     groupvariable <- groupvariable[,1] # ensures groupvariable is not a list
     means <- aggregate(as.matrix(variables) ~ groupvariable, FUN = mean)
     names(means) <- variablenames
     print(paste("Means:"))
     print(means)
     # within each group, find the standard deviation of each variable:
     sds <- aggregate(as.matrix(variables) ~ groupvariable, FUN = sd)
     names(sds) <- variablenames
     print(paste("Standard deviations:"))
     print(sds)
     # within each group, find the number of samples:
     samplesizes <- aggregate(as.matrix(variables) ~ groupvariable, FUN = length)
     names(samplesizes) <- variablenames
     print(paste("Sample sizes:"))
     print(samplesizes)
  }
printMeanAndSdByGroup(pats.lda.values$x,pats[1])
pats.lda
library("MASS")
pats.lda <- lda(pats$V1 ~ pats$V2 + pats$V3 +pats$V4 + pats$V5 + pats$V6 + pats$V7 + pats$V8 +
                   pats$V9 + pats$V10 + pats$V11 + pats$V12 + pats$V13 + pats$V14 + pats$V15 + pats$V16)
pats.lda.values <- predict(pats.lda, pats[2:16])
pats.lda.values$x[,1]
printMeanAndSdByGroup(pats.lda.values$x,pats[1])
calcAllocationRuleAccuracy <- function(ldavalue, groupvariable, cutoffpoints)
  {
     # find out how many values the group variable can take
     groupvariable2 <- as.factor(groupvariable[[1]])
     levels <- levels(groupvariable2)
     numlevels <- length(levels)
     # calculate the number of true positives and false negatives for each group
     numlevels <- length(levels)
     for (i in 1:numlevels)
     {
        leveli <- levels[i]
        levelidata <- ldavalue[groupvariable==leveli]
        # see how many of the samples from this group are classified in each group
        for (j in 1:numlevels)
        {
           levelj <- levels[j]
           if (j == 1)
           {
              cutoff1 <- cutoffpoints[1]
              cutoff2 <- "NA"
              results <- summary(levelidata <= cutoff1)
           }
           else if (j == numlevels)
           {
              cutoff1 <- cutoffpoints[(numlevels-1)]
              cutoff2 <- "NA"
              results <- summary(levelidata > cutoff1)
           }
           else
           {
              cutoff1 <- cutoffpoints[(j-1)]
              cutoff2 <- cutoffpoints[(j)]
              results <- summary(levelidata > cutoff1 & levelidata <= cutoff2)
           }
           trues <- results["TRUE"]
           trues <- trues[[1]]
           print(paste("Number of samples of group",leveli,"classified as group",levelj," : ",
              trues,"(cutoffs:",cutoff1,",",cutoff2,")"))
        }
     }
  }
calcAllocationRuleAccuracy(pats.lda.values$x[,1], pats[1], c(0.325, 0.234, -2.56))
q()
mosthighlycorrelated <- function(mydataframe,numtoreport)
  {
     # find the correlations
     cormatrix <- cor(mydataframe)
     # set the correlations on the diagonal or lower triangle to zero,
     # so they will not be reported as the highest ones:
     diag(cormatrix) <- 0
     cormatrix[lower.tri(cormatrix)] <- 0
     # flatten the matrix into a dataframe for easy sorting
     fm <- as.data.frame(as.table(cormatrix))
     # assign human-friendly names
     names(fm) <- c("First.Variable", "Second.Variable","Correlation")
     # sort and print the top n correlations
     head(fm[order(abs(fm$Correlation),decreasing=T),],n=numtoreport)
  }
mosthighlycorrelated(pats[2:16], 10)
quit
q()
ldahist(data = pats.lda.values$x[,1], g=pats$V1)
require(RColorBrewer)
ldahist(data = pats.lda.values$x[,1], g=pats$V1)
library("car")
ldahist(data = pats.lda.values$x[,1], g=pats$V1)
jpeg('lda1-stackHist.jpg')
ldahist(data = pats.lda.values$x[,1], g=pats$V1)
dev.off()
jpeg('lda2-stackHist.jpg')
ldahist(data = pats.lda.values$x[,2], g=pats$V1)
dev.off()
jpeg('lda3-stackHist.jpg')
ldahist(data = pats.lda.values$x[,3], g=pats$V1)
dev.off()
jpeg('lda-scatterplot.jpg')
plot(pats.lda.values$x[,1],pats.lda.values$x[,2]) # make a scatterplot
text(pats.lda.values$x[,1],pats.lda.values$x[,2],pats$V1,cex=0.7,pos=4,col="red") # add labels
dev.off()
jpeg('lda-scatterplot.jpg')
text(pats.lda.values$x[,1],pats.lda.values$x[,2],pats$V1,cex=0.7,pos=4,col="red") # add labels
plot(pats.lda.values$x[,1],pats.lda.values$x[,2]) # make a scatterplot
text(pats.lda.values$x[,1],pats.lda.values$x[,2],pats$V1,cex=0.7,pos=4,col="red") # add labels
jpeg('lda-scatterplot.jpg')
dev.off()
jpeg('lda-scatterplot.jpg')
plot(pats.lda.values$x[,1],pats.lda.values$x[,2]) # make a scatterplot
text(pats.lda.values$x[,1],pats.lda.values$x[,2],pats$V1,cex=0.7,pos=4,col="red") # add labels
dev.off()
jpeg('lda-scatterplot.jpg')
text(pats.lda.values$x[,1],pats.lda.values$x[,1],pats$V1,cex=0.7,pos=4,col="red") # add labels
plot(pats.lda.values$x[,1],pats.lda.values$x[,2]) # make a scatterplot
dev.off()
jpeg('lda-scatterplot.jpg')
plot(pats.lda.values$x[,1],pats.lda.values$x[,1]) # make a scatterplot
text(pats.lda.values$x[,1],pats.lda.values$x[,1],pats$V1,cex=0.7,pos=4,col="red") # add labels
dev.off()
jpeg('lda13-scatterplot.jpg')
plot(pats.lda.values$x[,1],pats.lda.values$x[,3]) # make a scatterplot
text(pats.lda.values$x[,1],pats.lda.values$x[,3],pats$V1,cex=0.7,pos=4,col="red") # add labels
dev.off()
printMeanAndSdByGroup(pats.lda.values$x,pats[1])
ct <- table(pats$V1, pats.lda$class)
pats.lda$class
ct <- table(pats$V1, pats.lda.values$class)
ct
q()
